# -*- coding: utf-8 -*-
"""SimulationStudy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BQ6UeGXXT4di_eVSlmN-P0xvXOKIbjvY
"""

import numpy as np
from scipy.stats import norm

def black_scholes_call(S0, K, T, r, sigma):

# compute the Black–Scholes price of a European call option.
# Parameters:
# S0 : Initial stock price S(0).
# K : Strike price.
# T : Time to maturity in years.
# r : Constant interest rate (per year).
# sigma : Volatility of the stock (per year, in GBM model).
# Theoretical Black–Scholes call price C(S0, K, T, r, sigma).

    if T <= 0 or sigma <= 0:
        return max(S0 - K, 0.0)

    # define d1, d2 as per Black-Scholes formula

    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    return S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def simulate_gbm_terminal(S0, mu, sigma, T, n_paths, seed=None):

# simulate terminal stock prices S(T) under the GBM model
# dS(t) = mu * S(t) dt + sigma * S(t) dB(t)
# using S(T) = S(0) * exp( (mu - 0.5*sigma^2)*T + sigma * sqrt(T) * Z )
# where Z ~ N(0, 1)
# Parameters
# S0 : Initial stock price S(0).
# mu : Drift parameter in the GBM model.
# sigma : Volatility parameter in the GBM model.
# T : Time horizon (in years).
# n_paths : Number of independent simulated terminal prices.
# seed : Random seed for reproducibility.

    if seed is not None:
        np.random.seed(seed)

    Z = np.random.randn(n_paths)
    drift = (mu - 0.5 * sigma**2) * T
    diffusion = sigma * np.sqrt(T) * Z
    ST = S0 * np.exp(drift + diffusion)

    return ST

def monte_carlo_call_price(S0, K, T, r, sigma, n_paths, seed=None):

# Estimate the European call price by Monte Carlo simulation
# under the GBM model using the same sigma as in Black–Scholes
# Parameters
# S0, K, T, r, sigma : As above
# n_paths : Number of simulated paths.
# seed : Random seed

    # for consistency with the Black–Scholes formula, set mu = r here.
    ST = simulate_gbm_terminal(S0, mu=r, sigma=sigma, T=T, n_paths=n_paths, seed=seed)

    # call payoff for each simulated terminal price
    payoffs = np.maximum(ST - K, 0.0)

    # discount average payoff back to time 0
    discounted_payoffs = np.exp(-r * T) * payoffs
    price_estimate = np.mean(discounted_payoffs)

    # standard error of the Monte Carlo estimator
    std_error = np.std(discounted_payoffs, ddof=1) / np.sqrt(n_paths)

    return price_estimate, std_error

if __name__ == "__main__":
    # initialize parameters for the toy call option and GBM model
    S0 = 100.0 # initial stock price
    K = 100.0 # strike price
    T = 1.0 # maturity (1 year)
    r = 0.02 # interest rate (2% per year)
    sigma = 0.20 # volatility (20% per year)

    # Black–Scholes theoretical price
    bs_price = black_scholes_call(S0, K, T, r, sigma)

    print("Toy Example: European Call Option Under GBM")
    print(f"Parameters: S0={S0}, K={K}, T={T}, r={r}, sigma={sigma}")
    print(f"Black–Scholes call price: {bs_price:.4f}\n")

    # Different simulation sizes to illustrate convergence
    path_list = [1_000, 5_000, 20_000, 100_000]

    header = (
        f"{'N_paths':>10} | {'MC Price':>10} | {'Std. Error':>10} | "
        f"{'95% CI Lower':>12} | {'95% CI Upper':>12} | {'|MC - BS|':>10}"
    )
    print(header)
    print("-" * len(header))

    for n_paths in path_list:
        mc_price, se = monte_carlo_call_price(
            S0, K, T, r, sigma, n_paths, seed=123
        )

        ci_lower = mc_price - 1.96 * se
        ci_upper = mc_price + 1.96 * se
        abs_error = abs(mc_price - bs_price)

        print(
            f"{n_paths:10d} | "
            f"{mc_price:10.4f} | "
            f"{se:10.4f} | "
            f"{ci_lower:12.4f} | "
            f"{ci_upper:12.4f} | "
            f"{abs_error:10.4f}"
        )