# -*- coding: utf-8 -*-
"""Application.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MmzBx2UjPdiU9Q5PICtHgElqLK39q0sn
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import files
from scipy.stats import norm, jarque_bera, skew, kurtosis

# Goal:
#   1) Compute daily log returns R_t = ln(S_t / S_{t-1})
#   3) Estimate GBM parameters (mu_hat, sigma_hat)
#   4) Diagnose GBM assumption: "log returns are Normal"
#   5) Use fitted GBM to simulate future prices (distributional prediction)
#   6) Price a hypothetical European call option:
#        - Black–Scholes closed form
#        - Monte Carlo using GBM simulations

uploaded = files.upload()

# store dataset

df = pd.read_csv("sp500_daily.csv")
df.head()

print("Loaded dataset.")
print("Shape (rows, cols):", df.shape)
print("Columns:", df.columns.tolist())
print("\nFirst 5 rows:\n", df.head())

# convert Date column to datetime and sort by date
df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
df = df.sort_values("Date").reset_index(drop=True)

# drop rows with missing or non-positive Close values
df = df.dropna(subset=["Date", "Close"]).copy()
df = df[df["Close"] > 0].copy()

print("\nAfter cleaning:")
print("Earliest date:", df["Date"].min())
print("Latest date:", df["Date"].max())
print("Number of usable rows:", len(df))

# seed for reproducibility

RANDOM_SEED = 495
np.random.seed(RANDOM_SEED)

# compute daily log returns

# daily step size Δt = 1/252 years (approx. trading days/year)
DT = 1.0 / 252.0

# extract price series S_t as daily closing prices
S = df["Close"].astype(float).values

# daily log returns:R_t = ln(S_t / S_{t-1})
log_returns = np.log(S[1:] / S[:-1])

# return at index t corresponds to going from day t-1 to day t
return_dates = df["Date"].iloc[1:].values

print("\nComputed log returns.")
print("Number of returns:", len(log_returns))
print("First 5 log returns:", log_returns[:5])

# estimate GBM parameters (mu_hat, sigma_hat)

# under GBM: dS(t) = μ S(t) dt + σ S(t) dB(t)

# for log returns over a small Δt:
# R_t = ln(S_t/S_{t-1}) ~ Normal( (μ - 0.5 σ^2) Δt ,  σ^2 Δt )

# m_hat = sample mean of daily log returns
# v_hat = sample variance of daily log returns
# estimate:
# μ_hat = (m_hat / Δt) + 0.5 σ_hat^2
# σ_hat^2 = v_hat / Δt

m_hat = np.mean(log_returns)
# ddof=1 gives sample variance
v_hat = np.var(log_returns, ddof=1)

sigma2_hat = v_hat / DT
sigma_hat = np.sqrt(sigma2_hat)

mu_hat = (m_hat / DT) + 0.5 * sigma2_hat

print("\nGBM parameter estimates:")
print(f"Mean daily log return m_hat = {m_hat:.8f}")
print(f"Var  daily log return v_hat = {v_hat:.8e}")
print(f"Estimated drift mu_hat = {mu_hat:.4f} per year")
print(f"Estimated volatility sigma_hat = {sigma_hat:.4f} per year")

# check to see if log-returns R_t look approximately Normal

# theoretical mean & std for daily log returns implied by fitted GBM
gbm_mean_daily = (mu_hat - 0.5 * sigma2_hat) * DT
gbm_std_daily = sigma_hat * np.sqrt(DT)

print(f"Theoretical mean  = {gbm_mean_daily:.8f}")
print(f"Theoretical std   = {gbm_std_daily:.8f}")

# plot distributions

plt.figure()
plt.hist(log_returns, bins=60, density=True)
plt.title("Histogram of daily log returns (S&P 500 Close)")
plt.xlabel("Daily log return")
plt.ylabel("Density")

x_grid = np.linspace(log_returns.min(), log_returns.max(), 500)
plt.plot(x_grid, norm.pdf(x_grid, loc=gbm_mean_daily, scale=gbm_std_daily))
plt.legend(["Normal fit implied by GBM", "Empirical histogram"])

plt.show()

# summary statistics
emp_skew = skew(log_returns)
emp_kurt = kurtosis(log_returns, fisher=True)

print(f"Skewness            = {emp_skew:.4f}")
print(f"Excess kurtosis     = {emp_kurt:.4f}")

S0 = df["Close"].iloc[-1]
S0

# GBM simulation
# not forecasting exact next price.
# instead generate a distribution of possible future prices S(T).

def simulate_gbm_paths(S0, mu, sigma, T_years, n_steps, n_paths, seed=None):

# Parameters
# S0 : initial price at time 0
# mu : drift parameter
# sigma : volatility parameter
# T_years : time horizon in years (1.0 for one year)
# n_steps : number of time steps in the simulation grid
# n_paths : number of independent simulated paths.
# seed : random seed for reproducibility

# Returns
# times : ndarray shape (n_steps+1,)
# Time grid in years from 0 to T_years
# paths : ndarray shape (n_paths, n_steps+1)
# Simulated paths. paths[i, t] is price on path i at time index t

    if seed is not None:
        np.random.seed(seed)

    # size of each simulation step in years, dt
    dt = T_years / n_steps
    times = np.linspace(0.0, T_years, n_steps + 1)

    # matrix to store simulated prices
    paths = np.zeros((n_paths, n_steps + 1), dtype=float)
    paths[:, 0] = S0

    # increments for GBM:
    # S_{t+1} = S_t * exp( (mu - 0.5 sigma^2) dt + sigma sqrt(dt) Z )
    # where Z ~ N(0,1) i.i.d.
    drift = (mu - 0.5 * sigma**2) * dt
    diffusion_scale = sigma * np.sqrt(dt)

    # simulation loop
    for step in range(1, n_steps + 1):
        Z = np.random.randn(n_paths)
        paths[:, step] = paths[:, step - 1] * np.exp(drift + diffusion_scale * Z)

    return times, paths


# simulation parameters
S0 = float(S[-1]) # last observed closing value as "today"
T_FORECAST = 1.0 # 1 year
N_STEPS = 252 # daily steps over 1 year
N_PATHS = 20000 # number of Monte Carlo paths

# run simulation
times, paths = simulate_gbm_paths(
    S0=S0, mu=mu_hat, sigma=sigma_hat,
    T_years=T_FORECAST, n_steps=N_STEPS, n_paths=N_PATHS,
    seed=RANDOM_SEED
)

# extract terminal prices
ST = paths[:, -1]

# summarize distribution
q05, q50, q95 = np.quantile(ST, [0.05, 0.50, 0.95])

print("\nGBM forecast distribution (1-year horizon):")
print(f"Current S0 = {S0:.2f}")
print(f"5th percentile  S(T) ≈ {q05:.2f}")
print(f"Median          S(T) ≈ {q50:.2f}")
print(f"95th percentile S(T) ≈ {q95:.2f}")

# visualize 30 paths
plt.figure()
for i in range(30):
    plt.plot(times, paths[i, :])
plt.title("Sample of simulated GBM paths (fitted to S&P 500 returns)")
plt.xlabel("Time (years)")
plt.ylabel("Simulated index level")
plt.show()

def simulate_gbm_terminal(S0, mu, sigma, T, n_paths, seed=None):

# simulate terminal stock prices S(T) under the GBM model
# dS(t) = mu * S(t) dt + sigma * S(t) dB(t)
# using S(T) = S(0) * exp( (mu - 0.5*sigma^2)*T + sigma * sqrt(T) * Z )
# where Z ~ N(0, 1)
# Parameters
# S0 : Initial stock price S(0).
# mu : Drift parameter in the GBM model.
# sigma : Volatility parameter in the GBM model.
# T : Time horizon (in years).
# n_paths : Number of independent simulated terminal prices.
# seed : Random seed for reproducibility.

    if seed is not None:
        np.random.seed(seed)

    Z = np.random.randn(n_paths)
    drift = (mu - 0.5 * sigma**2) * T
    diffusion = sigma * np.sqrt(T) * Z
    ST = S0 * np.exp(drift + diffusion)

    return ST

def monte_carlo_call_price(S0, K, T, r, sigma, n_paths, seed=None):

# Estimate the European call price by Monte Carlo simulation
# under the GBM model using the same sigma as in Black–Scholes
# Parameters
# S0, K, T, r, sigma : As above
# n_paths : Number of simulated paths.
# seed : Random seed

    # for consistency with the Black–Scholes formula, set mu = r here.
    ST = simulate_gbm_terminal(S0, mu=r, sigma=sigma, T=T, n_paths=n_paths, seed=seed)

    # call payoff for each simulated terminal price
    payoffs = np.maximum(ST - K, 0.0)

    # discount average payoff back to time 0
    discounted_payoffs = np.exp(-r * T) * payoffs
    price_estimate = np.mean(discounted_payoffs)

    # standard error of the Monte Carlo estimator
    std_error = np.std(discounted_payoffs, ddof=1) / np.sqrt(n_paths)

    return price_estimate, std_error

# option pricing with estimated sigma_hat
# choose K, T, and r
# compute Black–Scholes price using sigma_hat
# compute Monte estimated using GBM simulation

def black_scholes_call(S0, K, T, r, sigma):

# compute the Black–Scholes price of a European call option.
# Parameters:
# S0 : Initial stock price S(0).
# K : Strike price.
# T : Time to maturity in years.
# r : Constant interest rate (per year).
# sigma : Volatility of the stock (per year, in GBM model).
# Theoretical Black–Scholes call price C(S0, K, T, r, sigma).

    if T <= 0 or sigma <= 0:
        return max(S0 - K, 0.0)

    # define d1, d2 as per Black-Scholes formula

    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    return S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# hypothetical option parameters
# ideally r is a risk-free annual rate so choosing a plausible constant value

T_OPT = 1.0
r = 0.04
K = 1.05 * S0

print("\nHypothetical option parameters:")
print(f"S0 = {S0:.2f}, K = {K:.2f}, T = {T_OPT:.2f} years, r = {r:.2%}")
print(f"Using historical volatility estimate sigma_hat = {sigma_hat:.4f}")

# black–Scholes price (closed form)
C_BS = black_scholes_call(S0=S0, K=K, T=T_OPT, r=r, sigma=sigma_hat)
print(f"\nBlack–Scholes call price: {C_BS:.4f}")

# GBM estimated price under risk-neutral drift
N_MC = 200000
C_MC, SE_MC = monte_carlo_call_price(S0=S0, K=K, T=T_OPT, r=r, sigma=sigma_hat, n_paths=N_MC, seed=RANDOM_SEED)
CI_low = C_MC - 1.96 * SE_MC
CI_high = C_MC + 1.96 * SE_MC

print("\nMonte Carlo call price (risk-neutral GBM):")
print(f"Paths N = {N_MC}")
print(f"MC price estimate = {C_MC:.4f}")
print(f"Standard error    = {SE_MC:.4f}")
print(f"95% CI            = [{CI_low:.4f}, {CI_high:.4f}]")
print(f"\nAbsolute difference |MC - BS| = {abs(C_MC - C_BS):.4f}")